# 251107

## 1. Proposed Design (Current Logic Summary)

(1) Designate a string to embed as a watermark. Bit map this string and assign mapped bit array as a payload. 
    Declare a count variable step_t.
(2) Start generating a prompt.
---Pocess of selecting a token (a single step)---
(2-1) Take top-k tokens as input. (k is selected manually)
---Divide candidate token (iterate k times)---
(2-2) Divide the token into Choseong, Jungseong, and Jongseong by unicode arithmeic decomposition.
      Each divided fraction of the token has integer value now. 
      (If the token is not Hangul, or if it is a special character, skip this token.)
(2-3) Select one of the divided fractions (Choseong, Jungseong, and Jongseong). 
      (Current method is just a simple mod calculation, which is to be modified)
      Find 0 or 1 bit value by a hash equation of selected fraction.
(2-4) If this bit matches current step_t of payload, choose token which has this fraction. 
      Increase step_t by 1 and save selected token to an array (token_str)
(2-4-1) If the bit does not match, skip this token. Value of step_t is unchanged.
(3) Print generated prompt. (The number of tokens to be printed is designated manually)
(4) Conduct detection process and check if the watermark has been successfully inserted.
---Detection---
(4-1) Take the array of tokens (token_str) of generated prompt as input.
---Inspect each token (iterate as token_str's length)---
(4-2) If token is Hangul, divide its last syllable into fractions. (Same as watermarking method)
(4-3) Select one of the divided fractions (Choseong, Jungseong, and Jongseong).
      Find 0 or 1 bit value by a hash equation (order of selecting fraction is also same as watermarking method)
(4-4) If this value matches with payload's current step_t, this is a fraction of watermarked token.
      Thus, add this bit value to detected (extracted) payload.
(5) Divide detected payload by 8 bits and make it as a byte. Add this byte to regenerated watermark array.
    Check if it is same as acually watermarked text.

## 2. Feedbacks and suggestions

- What if skipped token's bit matches watermark's bit? Is it a possible error or not?
- How to evenly distribute watermark bits? Is it able to embed string watermark efficiently into large size of text?
- Need to analyze difference between watermarked text and unwatermarked text.
- Given generated text only, is it possible to retrieve tokens that are same as originally generated ones?
